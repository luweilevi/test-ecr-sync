name: "Sync docker image"
description: "Copies a docker image to a target repository, its asusmed the source repo for the image is authenticated"
inputs:
  image:
    description: "Path of image to sync without repo, example: tradeshift-base/<component>:<version>"
    required: true
  target-image:
    description: "Target new image name, example: tradeshift-public/<component>:<version>"
    required: false
  source-repo:
    description: "Name of source repo to sync from, example: eu.gcr.io"
    required: true
  target-repo:
    description: "Name of target repo, example: tradeshift-registry.eu-central-1.cr.aliyuncs.com"
    required: true
  target_user:
    description: "Username for target repository"
    required: false
  target_password:
    description: "Password for target repository"
    required: false
runs:
  using: "composite"
  steps:
    - id: docker-sync
      if: ${{ !contains(inputs.target-repo, 'amazonaws.com.cn') }}
      shell: bash
      run: |
        if which regctl ; then
            REGCTL="$(which regctl)"
        else
            cat >regctl <<EOF
            #!/bin/sh
            opts=""
            case "\$*" in
              "registry login"*) opts="-t";;
            esac
            docker container run \$opts -i --rm --net host \\
              -u "\$(id -u):\$(id -g)" -e HOME -v \$HOME:\$HOME \\
              -v /etc/docker/certs.d:/etc/docker/certs.d:ro \\
              regclient/regctl:latest "\$@"
        EOF
            chmod 755 regctl
            REGCTL="$(pwd)/regctl"
        fi
        if [ -n "${{ inputs.target_user }}" ] && [ -n "${{ inputs.target_password }}" ]; then
          docker login -u ${{ inputs.target_user }} -p ${{ inputs.target_password }} ${{ inputs.target-repo }};
        fi
        $REGCTL image copy -v info ${{ inputs.source-repo }}/${{ inputs.image }} ${{ inputs.target-repo }}/${{ inputs.target-image || inputs.image }}

    - id: sync-ecr
      if: ${{ contains(inputs.target-repo, 'amazonaws.com.cn') }}
      env:
        AWS_ACCESS_KEY_ID: ${{ inputs.target_user }}
        AWS_SECRET_ACCESS_KEY: ${{ inputs.target_password }}
        AWS_DEFAULT_REGION: cn-northwest-1
        ecr_iam_policy: >
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Sid": "AllowCrossAccountPushPull",
                "Effect": "Allow",
                "Principal": {
                  "AWS": [
                    "arn:aws:iam::615254691163:role/ts_all_test_ci-it-slave_role",
                    "arn:aws:iam::615254691163:role/ts_all_test_ci-components-slave_role",
                    "arn:aws:iam::694518486591:role/ts_all_base_administrator_role",
                    "arn:aws:iam::615254691163:role/ts_all_test_ts_github-actions-runner_role",
                    "arn:aws-cn:iam::121118285438:role/ts_all_sand_administrator_role"
                  ]
                },
                "Action": [
                  "ecr:BatchCheckLayerAvailability",
                  "ecr:BatchGetImage",
                  "ecr:CompleteLayerUpload",
                  "ecr:DescribeImageScanFindings",
                  "ecr:DescribeImages",
                  "ecr:DescribeRepositories",
                  "ecr:GetAuthorizationToken",
                  "ecr:GetDownloadUrlForLayer",
                  "ecr:GetRepositoryPolicy",
                  "ecr:InitiateLayerUpload",
                  "ecr:ListImages",
                  "ecr:PutImage",
                  "ecr:UploadLayerPart"
                ]
              }
            ]
          }
        lifecyle_policy: >
          {
            "rules": [
              {
                "rulePriority": 1,
                "description": "Keep last 150 images",
                "selection": {
                  "tagStatus": "any",
                  "countType": "imageCountMoreThan",
                  "countNumber": 150
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }
      shell: bash
      run: |
        repo_part=$(echo ${{ inputs.image }} | sed 's/:.*//g')
        repo_name=${{ inputs.target-repo }}/$repo_part
        echo "$repo_name"
        aws configure set aws_access_key_id ${{ inputs.target_user }}
        aws configure set aws_secret_access_key ${{ inputs.target_password }}
        aws ecr describe-repositories --region cn-northwest-1 --repository-names ${repo_name}
        output=$(aws ecr describe-repositories --region cn-northwest-1 --repository-names ${repo_name} 2>&1)
        echo "$output"
        if [ $? -ne 0 ]; then
          if echo ${output} | grep -q RepositoryNotFoundException; then
            echo "creating repo"
          else
            >&2 echo ${output}
          fi
        fi

#        if which regctl ; then
#          REGCTL="$(which regctl)"
#        else
#          cat >regctl <<EOF
#          #!/bin/sh
#          opts=""
#          case "\$*" in
#            "registry login"*) opts="-t";;
#          esac
#          docker container run \$opts -i --rm --net host \\
#            -u "\$(id -u):\$(id -g)" -e HOME -v \$HOME:\$HOME \\
#            -v /etc/docker/certs.d:/etc/docker/certs.d:ro \\
#            regclient/regctl:latest "\$@"
#        EOF
#            chmod 755 regctl
#            REGCTL="$(pwd)/regctl"
#        fi
#        aws ecr get-login-password --region cn-northwest-1 | docker login --username AWS --password-stdin ${{ inputs.target-repo }}
#        $REGCTL image copy -v info ${{ inputs.source-repo }}/${{ inputs.image }} ${{ inputs.target-repo }}/${{ inputs.target-image || inputs.image }}
#        cat ./policyfiles/cn-ecr-iam-policy.json


